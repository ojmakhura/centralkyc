// Generated by andromda-angular cartridge (view\view.component.imp.ts.vsl) CAN EDIT!
import { Component, computed, effect, inject, signal } from '@angular/core';
import { IndividualDetailsComponent } from '@app/view/individual/individual-details.component';
import { IndividualDetailsVarsForm } from '@app/view/individual/individual-details.component';
import { MatRadioChange } from '@angular/material/radio';
import { MatCheckboxChange } from '@angular/material/checkbox';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { TranslateModule } from '@ngx-translate/core';
import { MaterialModule } from '@app/material.module';
import { TableComponent } from '@app/components/table/table.component';
import { LoaderComponent } from '@app/@shared/loader/loader.component';
import { SettingsApiStore } from '@app/store/bw/co/centralkyc/settings/settings-api.store';
import { DocumentTypeDTO } from '@app/model/bw/co/centralkyc/document/type/document-type-dto';
import { DocumentApi } from '@app/service/bw/co/centralkyc/document/document-api';
import { DocumentApiStore } from '@app/store/bw/co/centralkyc/document/document-api.store';
import { TargetEntity } from '@app/model/bw/co/centralkyc/target-entity';
import { HttpClient } from '@angular/common/http';
import { Observable, of } from 'rxjs';
import { DocumentDTO } from '@app/model/bw/co/centralkyc/document/document-dto';
import { EmploymentRecordApiStore } from '@app/store/bw/co/centralkyc/individual/employment/employment-record-api.store';
import { KycRecordApiStore } from '@app/store/bw/co/centralkyc/individual/kyc/kyc-record-api.store';

// Interface for upload progress tracking
interface UploadProgress {
  [documentTypeId: string]: {
    isUploading: boolean;
    progress: number;
  };
}

@Component({
  selector: 'app-individual-details',
  templateUrl: './individual-details.component.html',
  styleUrls: ['./individual-details.component.scss'],
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule, TranslateModule, MaterialModule, LoaderComponent],
})
export class IndividualDetailsImplComponent extends IndividualDetailsComponent {
  override error = this.individualApiStore.error;
  override messages = this.individualApiStore.messages;
  override success = this.individualApiStore.success;
  individual = this.individualApiStore.data;

  employmentRecordStore = inject(EmploymentRecordApiStore);
  employmentRecords = this.employmentRecordStore.dataList;

  kycRecordStore = inject(KycRecordApiStore);
  kycRecords = this.kycRecordStore.dataList;

  // Settings and document types
  settingsApiStore = inject(SettingsApiStore);
  documentApi = inject(DocumentApi);
  documentApiStore = inject(DocumentApiStore);
  private http = inject(HttpClient);

  // Document upload state
  uploadedDocuments = this.documentApiStore.dataList;
  uploadProgress = signal<UploadProgress>({});

  // Computed property to get individual document types from settings
  individualDocumentTypes = computed(() => {
    const settings = this.settingsApiStore.data();
    return settings?.individualDocuments || [];
  });
  kycIndDocumentTypes = computed(() => {
    const settings = this.settingsApiStore.data();
    return settings?.indKycDocuments || [];
  });

  constructor() {
    super();

    effect(() => {
      let individual = this.individualApiStore.data();
      if (individual) {
        this.individualDetailsForm.patchValue(individual);
        // Load existing documents for this individual
        this.loadIndividualDocuments(individual.id);
        this.loadKycRecords(individual.id);
        this.loadEmploymentRecords(individual.id);
      }
    });

    effect(() => {
      const doc = this.documentApiStore.data();

      if (doc.targetId) {
        this.loadIndividualDocuments(doc.targetId);
      }
    });

    // Load settings to get document types
    this.settingsApiStore.getAll();
  }

  override beforeOnInit(form: IndividualDetailsVarsForm): IndividualDetailsVarsForm {
    this.individualApiStore.reset();
    this.settingsApiStore.reset();
    this.settingsApiStore.getAll();

    this.route.queryParams.subscribe((params: any) => {
      if (params.id) {
        this.individualApiStore.findById(params);
      }
    });

    return form;
  }

  loadKycRecords(individualId: string): void {
    this.kycRecordStore.findByIndividual({ individualId });
  }

  loadEmploymentRecords(individualId: string): void {
    this.employmentRecordStore.findByIndividual({ individualId });
  }

  doNgOnDestroy(): void {}

  // Document upload event handlers
  onDragOver(event: DragEvent): void {
    event.preventDefault();
    event.stopPropagation();
    const target = event.currentTarget as HTMLElement;
    target.classList.add('drag-over');
  }

  onDragLeave(event: DragEvent): void {
    event.preventDefault();
    event.stopPropagation();
    const target = event.currentTarget as HTMLElement;
    target.classList.remove('drag-over');
  }

  onFileDropped(event: DragEvent, docType: DocumentTypeDTO): void {
    event.preventDefault();
    event.stopPropagation();
    const target = event.currentTarget as HTMLElement;
    target.classList.remove('drag-over');

    const files = event.dataTransfer?.files;
    if (files && files.length > 0) {
      this.handleFileUpload(files[0], docType);
    }
  }

  onFileSelected(event: Event, docType: DocumentTypeDTO): void {
    const target = event.target as HTMLInputElement;
    const files = target.files;
    if (files && files.length > 0) {
      this.handleFileUpload(files[0], docType);
    }
    // Reset the input value to allow selecting the same file again
    target.value = '';
  }

  private handleFileUpload(file: File, docType: DocumentTypeDTO): void {
    // Validate file
    if (!this.validateFile(file)) {
      return;
    }

    const individual = this.individual();
    if (!individual?.id) {
      this.toaster.error('No individual selected for document upload');
      return;
    }

    // Update upload progress to show uploading state
    this.updateUploadProgress(docType.id!, true, 0);

    // Use DocumentApiStore's upload method for better state management
    this.documentApiStore.upload({
      target: TargetEntity.INDIVIDUAL,
      targetId: individual.id,
      documentTypeId: docType.id!,
      file: file,
    });

    // Subscribe to the store's state changes to track upload progress
  }
  private validateFile(file: File): boolean {
    // Check file size (max 10MB)
    const maxSize = 10 * 1024 * 1024;
    if (file.size > maxSize) {
      this.toaster.error('File size must be less than 10MB');
      return false;
    }

    // Check file type
    const allowedTypes = [
      'application/pdf',
      'image/jpeg',
      'image/jpg',
      'image/png',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    ];
    if (!allowedTypes.includes(file.type)) {
      this.toaster.error('Invalid file type. Only PDF, JPG, PNG, DOC, and DOCX files are allowed');
      return false;
    }

    return true;
  }

  private updateUploadProgress(documentTypeId: string, isUploading: boolean, progress: number): void {
    const currentProgress = this.uploadProgress();
    this.uploadProgress.set({
      ...currentProgress,
      [documentTypeId]: { isUploading, progress },
    });
  }

  // Document management methods
  getUploadedDocument(documentTypeId?: string): DocumentDTO | undefined {

    if(!documentTypeId) return undefined;

    const docs = this.uploadedDocuments() || [];
    return docs.find((doc) => doc.documentTypeId === documentTypeId);
  }

  isUploading(documentTypeId?: string): boolean {

    if(!documentTypeId) return false;

    return this.uploadProgress()[documentTypeId]?.isUploading || false;
  }

  getUploadProgress(documentTypeId?: string): number {

    if(!documentTypeId) return 0;

    return this.uploadProgress()[documentTypeId]?.progress || 0;
  }

  downloadDocument(doc: DocumentDTO): void {
    console.log(document);

    this.documentApi.downloadFile(doc.id).subscribe({
      next: (res: any) => {
        const url = window.URL.createObjectURL(res);
        const a = document.createElement('a');
        a.href = url;

        // Optional: set a meaningful filename
        a.download = `${doc.fileName}.pdf`; // or dynamically get filename from backend
        a.click();

        window.URL.revokeObjectURL(url); // clean up
      },
      error: (err: any) => {
        this.toaster.error(err.message || 'Failed to download file', 'Download Error');
      },
      complete: () => {
        // this.isDownloading.set('');
      },
    });
  }

  deleteDocument(documentTypeId?: string): void {

    if (!documentTypeId) return;

    const document = this.getUploadedDocument(documentTypeId);
    if (!document) return;

    if (confirm(`Are you sure you want to delete "${document.fileName}"?`)) {
      this.documentApi.remove(document.id).subscribe({
        next: (response) => {
          if (response.success) {
            this.loadIndividualDocuments(document.targetId!);
            this.toaster.success('Document deleted successfully');
          } else {
            this.toaster.error(`Failed to delete document: ${response.message || 'Unknown error'}`);
          }
        },
        error: (error) => {
          console.error('Delete error:', error);
          this.toaster.error(`Failed to delete document: ${error.message || 'Delete failed'}`);
        },
      });
    }
  }

  formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  private loadIndividualDocuments(individualId: string): void {
    this.documentApiStore.findByTarget({ target: TargetEntity.INDIVIDUAL, targetId: individualId });
  }
}
