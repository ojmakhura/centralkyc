// Generated by andromda-angular cartridge (view\view.component.ts.vsl) DO NOT EDIT
import { 
    Component, 
    OnInit, 
    effect,
    inject, 
    ViewChild, 
    Input, 
    Output, 
    EventEmitter, 
    AfterViewInit,
    signal,
    Signal,
    OnDestroy,
    linkedSignal,
} from '@angular/core';
import { 
    form,
    required,
    email,
    min,
    minLength, 
    max,
    maxLength,
} from "@angular/forms/signals";
import { ActivatedRoute, Router } from '@angular/router';
import {COMMA, ENTER} from '@angular/cdk/keycodes';
import { 
    FormGroup, 
    FormControl, 
    FormArray, 
    FormBuilder, 
    ReactiveFormsModule, 
    Validators 
} from '@angular/forms';
import { formatDate } from '@angular/common';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatSelectChange } from '@angular/material/select';
import { MatRadioChange } from '@angular/material/radio';
import { MatCheckboxChange } from '@angular/material/checkbox';
import { UseCaseScope } from '@app/utils/use-case-scope';
import { Observable, of, Subscription } from 'rxjs';
import { SearchObject } from '@models/search-object';
import { MatDialog } from '@angular/material/dialog';
import { MatTableDataSource } from '@angular/material/table';
import { MatChipInputEvent } from '@angular/material/chips';
import { MatAutocompleteSelectedEvent } from '@angular/material/autocomplete';
import { TableComponent } from '@components/table/table';
import { ColumnModel } from '@models/column.model';
import { ActionTemplate } from '@models/action-template';

import { OrganisationApi } from '@services/bw/co/centralkyc/organisation/organisation-api';
import { GeneralStatus } from '@models/bw/co/centralkyc/general-status';
import { ClientRequestDTO } from '@models/bw/co/centralkyc/organisation/client/client-request-dto';
import { BranchDTO } from '@models/bw/co/centralkyc/organisation/branch/branch-dto';
import { ClientRequestStatus } from '@models/bw/co/centralkyc/organisation/client/client-request-status';
import { DocumentTypeDTO } from '@models/bw/co/centralkyc/document/type/document-type-dto';
import { TargetEntity } from '@models/bw/co/centralkyc/target-entity';
import { OrganisationControllerImpl } from '@controllers/organisation/organisation-controller-impl';
import { DocumentDTO } from '@models/bw/co/centralkyc/document/document-dto';
import { IndividualIdentityType } from '@models/bw/co/centralkyc/individual/individual-identity-type';
import { OrganisationDTO } from '@models/bw/co/centralkyc/organisation/organisation-dto';
import { ToastrService } from 'ngx-toastr';
import { Page } from '@app/models/page.model';
import { OrganisationDomain } from '@models/bw/co/centralkyc/organisation/organisation-domain';

export class OrganisationDetailsVarsForm {
    id: string | any = null;
    createdAt: Date | any = null;
    createdBy: string | any = null;
    modifiedAt: Date | any = null;
    modifiedBy: string | any = null;
    status: GeneralStatus | any = null;
    registrationNo: string | any = null;
    code: string | any = null;
    name: string | any = null;
    description: string | any = null;
    postalAddress: string | any = null;
    physicalAddress: string | any = null;
    contactEmailAddress: string | any = null;
    domains: OrganisationDomain[] | any[] = [];
}

@Component({
  selector: 'app-organisation-details-base',
  template: ''
})
export abstract class OrganisationDetailsComponent implements OnInit, AfterViewInit, OnDestroy {

    separatorKeysCodes: number[] = [ENTER, COMMA];
    @Input() organisationDetailsVarsForm: OrganisationDetailsVarsForm = new OrganisationDetailsVarsForm();
    organisationDetailsSignal = signal(this.organisationDetailsVarsForm);
    organisationDetailsSignalForm = form(this.organisationDetailsSignal, (path) => {
      required(path.id, { message: 'id.required' })
      required(path.createdAt, { message: 'created.at.required' })
      required(path.createdBy, { message: 'created.by.required' })
      required(path.modifiedAt, { message: 'modified.at.required' })
      required(path.modifiedBy, { message: 'modified.by.required' })
      required(path.status, { message: 'status.required' })
      required(path.registrationNo, { message: 'registration.no.required' })
      required(path.code, { message: 'code.required' })
      required(path.name, { message: 'name.required' })
      required(path.description, { message: 'description.required' })
      required(path.postalAddress, { message: 'postal.address.required' })
      required(path.physicalAddress, { message: 'physical.address.required' })
    });
    
	    hide: boolean = false;
    protected route: ActivatedRoute = inject(ActivatedRoute);
    protected router: Router = inject(Router);
    protected formBuilder: FormBuilder = inject(FormBuilder);
    protected useCaseScope: UseCaseScope = inject(UseCaseScope);
    dialog: MatDialog = inject(MatDialog);
    toaster: ToastrService = inject(ToastrService);
    organisationController: OrganisationControllerImpl = inject(OrganisationControllerImpl);
    readonly organisationApi = inject(OrganisationApi);
        @ViewChild('phoneNumbersTable') phoneNumbersTable!: TableComponent<any[]>;
    phoneNumbersTableSignal: Signal<any[] | Page<any> | undefined> = signal(undefined);
    phoneNumbersTablePaged: boolean = true;
    
    phoneNumbersTableColumns: ColumnModel[] = [
    ];

    phoneNumbersTableColumnsActions: ActionTemplate[] = [
    ];

    showPhoneNumbersActions = false;

    @ViewChild('branchesTable') branchesTable!: TableComponent<Array<BranchDTO>>;
    branchesTableSignal: Signal<Array<BranchDTO> | Page<any> | undefined> = signal(undefined);
    branchesTablePaged: boolean = true;
    
    branchesTableColumns: ColumnModel[] = [
        new ColumnModel(
            'id', 
            'id',
            false,
        ),
        new ColumnModel(
            'code', 
            'code',
            false,
        ),
        new ColumnModel(
            'name', 
            'name',
            false,
        ),
    ];

    branchesTableColumnsActions: ActionTemplate[] = [
    ];

    showBranchesActions = false;

    @ViewChild('clientKycDocumentsTable') clientKycDocumentsTable!: TableComponent<Array<DocumentTypeDTO>>;
    clientKycDocumentsTableSignal: Signal<Array<DocumentTypeDTO> | Page<any> | undefined> = signal(undefined);
    clientKycDocumentsTablePaged: boolean = true;
    
    clientKycDocumentsTableColumns: ColumnModel[] = [
        new ColumnModel(
            'code', 
            'code',
            false,
        ),
        new ColumnModel(
            'name', 
            'name',
            false,
        ),
    ];

    clientKycDocumentsTableColumnsActions: ActionTemplate[] = [
    ];

    showClientKycDocumentsActions = false;

    @ViewChild('clientRequestsTable') clientRequestsTable!: TableComponent<Array<ClientRequestDTO>>;
    clientRequestsTableSignal = linkedSignal<Array<ClientRequestDTO> | Page<any> | undefined>(() => undefined);
    clientRequestsTablePaged: boolean = true;
    
    clientRequestsTableColumns: ColumnModel[] = [
        new ColumnModel(
            'identityNo', 
            'identity.no',
            false,
        ),
        new ColumnModel(
            'name', 
            'name',
            false,
        ),
        new ColumnModel(
            'emailAddress', 
            'email.address',
            false,
        ),
        new ColumnModel(
            'status', 
            'status',
            false,
        ),
    ];

    clientRequestsTableColumnsActions: ActionTemplate[] = [
    ];

    showClientRequestsActions = false;

    @ViewChild('clientRequestsFilesTable') clientRequestsFilesTable!: TableComponent<Array<DocumentDTO>>;
    clientRequestsFilesTableSignal: Signal<Array<DocumentDTO> | Page<any> | undefined> = signal(undefined);
    clientRequestsFilesTablePaged: boolean = true;
    
    clientRequestsFilesTableColumns: ColumnModel[] = [
        new ColumnModel(
            'target', 
            'target',
            false,
        ),
        new ColumnModel(
            'documentTypeId', 
            'document.type.id',
            false,
        ),
        new ColumnModel(
            'documentType', 
            'document.type',
            false,
        ),
        new ColumnModel(
            'url', 
            'url',
            false,
        ),
        new ColumnModel(
            'targetId', 
            'target.id',
            false,
        ),
        new ColumnModel(
            'metadata', 
            'metadata',
            false,
        ),
        new ColumnModel(
            'fileName', 
            'file.name',
            false,
        ),
        new ColumnModel(
            'id', 
            'id',
            false,
        ),
        new ColumnModel(
            'createdBy', 
            'created.by',
            false,
        ),
        new ColumnModel(
            'createdAt', 
            'created.at',
            false,
        ),
        new ColumnModel(
            'modifiedBy', 
            'modified.by',
            false,
        ),
        new ColumnModel(
            'modifiedAt', 
            'modified.at',
            false,
        ),
    ];

    clientRequestsFilesTableColumnsActions: ActionTemplate[] = [
    ];

    showClientRequestsFilesActions = false;


    GeneralStatusT: any = GeneralStatus;
    GeneralStatusOptions = Object.keys(this.GeneralStatusT);
    ClientRequestStatusT: any = ClientRequestStatus;
    ClientRequestStatusOptions = Object.keys(this.ClientRequestStatusT);
    TargetEntityT: any = TargetEntity;
    TargetEntityOptions = Object.keys(this.TargetEntityT);
    IndividualIdentityTypeT: any = IndividualIdentityType;
    IndividualIdentityTypeOptions = Object.keys(this.IndividualIdentityTypeT);
    loaderMessage: Signal<string> = signal('');
    messages: Signal<any> = signal({});
    success: Signal<boolean> = signal(false);
    loading = signal(false);
    error: Signal<boolean> = signal(false);
    selected: any = null;

    
    constructor() {


    effect(() => {
      let messages = this.messages();

      if(this.success() && !this.loading()) {
        this.toaster.success(messages[0]);
      }

      if (this.error() && !this.loading()) {
        this.toaster.error(messages[0]);
      }
    })
    }

    abstract beforeOnInit(form: OrganisationDetailsVarsForm): OrganisationDetailsVarsForm;
	
    ngOnInit() {
                
                                                
        this.afterOnInit();
    }

    handleFormChanges(change: any): void {
        
    }

    organisationDetailsFormReset() {

        this.organisationDetailsSignal.set(new OrganisationDetailsVarsForm());
    }

    afterOnInit(): void {}
    
    doNgAfterViewInit(): void {}

    ngAfterViewInit() {
        this.doNgAfterViewInit();
        this.organisationController.resetUseCaseScope();
    }

    newForm(organisationDetailsVarsForm: OrganisationDetailsVarsForm): FormGroup {
        return this.formBuilder.group({

        });
    }

    abstract doNgOnDestroy(): void;

    ngOnDestroy() { 
        this.doNgOnDestroy();
                            }


    /**
     * This method may be overwritten
     */
    beforeOrganisationDetailsEdit(form: any): void {}

    /**
     * This method may be overwritten
     */
    afterOrganisationDetailsEdit(form: any): void {}

    /**
     * This method may be overwritten
     */
    get organisationDetailsEditId(): string { 
        return {} as string;
    }

    organisationDetailsEdit(): void {

        let form: any = {
            id: this.organisationDetailsEditId,
        };

        this.beforeOrganisationDetailsEdit(form);

        this.organisationController.organisationDetailsEdit(form.id);
        this.afterOrganisationDetailsEdit(form);
    }

    

}
