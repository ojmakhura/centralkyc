// Generated by andromda-angular cartridge (view\view.component.imp.ts.vsl) CAN EDIT!
import { Component, computed, effect, inject, linkedSignal, signal } from '@angular/core';
import { IndividualDetailsComponent } from '@views/individual/details/individual-details';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { TranslateModule } from '@ngx-translate/core';
import { MaterialModule } from '@app/material.module';
import { TableComponent } from '@components/table/table';
import { Loader } from "@shared/loader/loader";
import { Field } from '@angular/forms/signals';
import { IndividualDTO } from '@app/models/bw/co/centralkyc/individual/individual-dto';
import { EmploymentRecordApi } from '@app/services/bw/co/centralkyc/individual/employment/employment-record-api';
import { KycRecordApi } from '@app/services/bw/co/centralkyc/kyc/kyc-record-api';
import { SettingsApi } from '@app/services/bw/co/centralkyc/settings/settings-api';
import { DocumentApi } from '@app/services/bw/co/centralkyc/document/document-api';
import { ClientRequestApi } from '@app/services/bw/co/centralkyc/organisation/client/client-request-api';
import { SettingsDTO } from '@app/models/bw/co/centralkyc/settings/settings-dto';
import { DocumentDTO } from '@app/models/bw/co/centralkyc/document/document-dto';
import { KycRecordDTO } from '@app/models/bw/co/centralkyc/kyc/kyc-record-dto';
import { EmploymentRecordDTO } from '@app/models/bw/co/centralkyc/individual/employment/employment-record-dto';
import { DocumentTypeDTO } from '@app/models/bw/co/centralkyc/document/type/document-type-dto';
import { TargetEntity } from '@app/models/bw/co/centralkyc/target-entity';
import { ClientRequestDTO } from '@app/models/bw/co/centralkyc/organisation/client/client-request-dto';
import { ClientRequestStatus } from '@app/models/bw/co/centralkyc/organisation/client/client-request-status';
import Swal from 'sweetalert2';
import { KycComplianceStatus } from '@app/models/bw/co/centralkyc/kyc/kyc-compliance-status';
import { PhoneNumber } from '@app/models/bw/co/centralkyc/phone-number';

interface UploadProgress {
  [documentTypeId: string]: {
    isUploading: boolean;
    progress: number;
  };
}

@Component({
  selector: 'app-individual-details',
  templateUrl: './individual-details.html',
  styleUrls: ['./individual-details.scss'],
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    ReactiveFormsModule,
    TranslateModule,
    MaterialModule,
    TableComponent,
    Loader,
    Field,
  ],
})
export class IndividualDetailsImplComponent extends IndividualDetailsComponent {


  override loaderMessage = linkedSignal(() => 'Loading...');
  override error = linkedSignal(() => false);
  override messages = linkedSignal(() => []);
  override success = linkedSignal(() => false);
  individual = linkedSignal(() => new IndividualDTO());

  employmentRecordApi = inject(EmploymentRecordApi);
  employmentRecords = linkedSignal<EmploymentRecordDTO[]>(() => []);

  kycRecordApi = inject(KycRecordApi);
  kycRecords = linkedSignal<KycRecordDTO[]>(() => []);

  clientRequestApi = inject(ClientRequestApi);
  clientRequests = linkedSignal<ClientRequestDTO[]>(() => []);
  clientRequestStatuses = Object.values(ClientRequestStatus);
  clientRequestsPageSize = signal<number>(10);
  clientRequestsPageIndex = signal<number>(0);
  clientRequestsTotalElements = signal<number>(0);

  // Settings and document types
  settingsApi = inject(SettingsApi);
  settings = linkedSignal<SettingsDTO | null>(() => null);
  documentApi = inject(DocumentApi);
  document = linkedSignal(() => new DocumentDTO());

  // Document upload state
  uploadedDocuments = linkedSignal<DocumentDTO[]>(() => []);
  uploadProgress = signal<UploadProgress>({});

  // Computed property to get individual document types from settings
  individualDocumentTypes = computed(() => {
    const settings = this.settings();
    return settings?.individualDocuments || [];
  });
  kycIndDocumentTypes = computed(() => {
    const settings = this.settings();
    return settings?.indKycDocuments || [];
  });

  constructor() {
    super();

    effect(() => {
      let individual = this.individual();
      // if (individual) {
      //   this.individualDetailsForm.patchValue(individual);
      //   // Load existing documents for this individual
      //   this.loadIndividualDocuments(individual.id);
      //   this.loadKycRecords(individual.id);
      //   this.loadEmploymentRecords(individual.id);
      // }
    });

    effect(() => {
      const doc = this.document();

      if (doc.targetId) {
        this.loadIndividualDocuments(doc.targetId);
      }
    });

    // Load settings to get document types
    // this.settingsApiStore.getAll();
    this.settingsApi.getAll().subscribe({
      next: (res) => {
        if (res && res.length > 0) {
          this.settings.set(res[0]);
        }
      },
      error: (err) => {
        console.error('Failed to load settings:', err);
      },
    });
  }

  override ngOnInit() {
    // this.individualApiStore.reset();
    // this.settingsApiStore.reset();
    // this.settingsApiStore.getAll();

    this.route.queryParams.subscribe((params: any) => {
      if (params.id) {
        this.individualApi.findById(params.id).subscribe({
          next: (res) => {
            this.individual.set(res);
            // Load related records
            this.loadIndividualDocuments(res.id);
            this.loadKycRecords(res.id);
            this.loadEmploymentRecords(res.id);
            this.loadClientRequests(res.id);
          },
          error: (err) => {
            console.error('Failed to load individual:', err);
          },
        });
      }
    });

  }

  loadKycRecords(individualId: string): void {
    this.kycRecordApi.findByIndividual(individualId).subscribe({
      next: (res) => {
        this.kycRecords.set(res);
      },
      error: (err) => {
        console.error('Failed to load KYC records:', err);
      },
    });
  }

  loadEmploymentRecords(individualId: string): void {
    this.employmentRecordApi.findByIndividual(individualId).subscribe({
      next: (res) => {
        this.employmentRecords.set(res);
      },
      error: (err) => {
        console.error('Failed to load employment records:', err);
      },
    });
  }

  loadClientRequests(individualId: string): void {
    const pageNumber = this.clientRequestsPageIndex();
    const pageSize = this.clientRequestsPageSize();

    this.clientRequestApi.findByIndividualPaged(individualId, pageNumber, pageSize).subscribe({
      next: (res) => {
        this.clientRequests.set(res.content || []);
        this.clientRequestsTotalElements.set(res.page.totalElements || 0);
      },
      error: (err) => {
        console.error('Failed to load client requests:', err);
      },
    });
  }

  onClientRequestsPageChange(event: any): void {
    this.clientRequestsPageIndex.set(event.pageIndex);
    this.clientRequestsPageSize.set(event.pageSize);
    const individual = this.individual();
    if (individual?.id) {
      this.loadClientRequests(individual.id);
    }
  }

  createNewClientRequest(): void {
    const individual = this.individual();
    if (!individual?.id) {
      this.toaster.error('No individual selected');
      return;
    }

    Swal.fire({
      title: 'Create Client Request',
      text: 'Are you sure you want to create a new client request for this individual?',
      icon: 'question',
      showCancelButton: true,
      confirmButtonText: 'Yes, create it!',
      cancelButtonText: 'No, cancel',
    }).then((result) => {
      if (result.isConfirmed) {
        const newRequest = new ClientRequestDTO();
        newRequest.name = `${individual.firstName} ${individual.surname}`;
        newRequest.registration = individual.identityNo;
        newRequest.identityType = individual.identityType;
        newRequest.emailAddress = individual.emailAddress;
        newRequest.status = ClientRequestStatus.PENDING;
        newRequest.target = TargetEntity.INDIVIDUAL;
        newRequest.targetId = individual.id;

        this.router.navigate(['/client-request/edit'], { queryParams: { individualId: individual.id } });
      }
    });
  }

  onClientRequestStatusChange(clientRequest: ClientRequestDTO, newStatus: ClientRequestStatus): void {
    const updatedRequest = { ...clientRequest, status: newStatus };
    this.clientRequestApi.save(updatedRequest).subscribe({
      next: (res) => {
        this.toaster.success('Client request status updated successfully');
        // Reload client requests to reflect changes
        const individual = this.individual();
        if (individual?.id) {
          this.loadClientRequests(individual.id);
        }
      },
      error: (err) => {
        console.error('Failed to update client request status:', err);
        this.toaster.error(`Failed to update status: ${err.message || 'Update failed'}`);
      },
    });
  }

  doNgOnDestroy(): void {}

  // Document upload event handlers
  onDragOver(event: DragEvent): void {
    event.preventDefault();
    event.stopPropagation();
    const target = event.currentTarget as HTMLElement;
    target.classList.add('drag-over');
  }

  onDragLeave(event: DragEvent): void {
    event.preventDefault();
    event.stopPropagation();
    const target = event.currentTarget as HTMLElement;
    target.classList.remove('drag-over');
  }

  onFileDropped(event: DragEvent, docType: DocumentTypeDTO): void {
    event.preventDefault();
    event.stopPropagation();
    const target = event.currentTarget as HTMLElement;
    target.classList.remove('drag-over');

    const files = event.dataTransfer?.files;
    if (files && files.length > 0) {
      this.handleFileUpload(files[0], docType);
    }
  }

  onFileSelected(event: Event, docType: DocumentTypeDTO): void {
    const target = event.target as HTMLInputElement;
    const files = target.files;
    if (files && files.length > 0) {
      this.handleFileUpload(files[0], docType);
    }
    // Reset the input value to allow selecting the same file again
    target.value = '';
  }

  private handleFileUpload(file: File, docType: DocumentTypeDTO): void {
    // Validate file
    if (!this.validateFile(file)) {
      return;
    }

    const individual = this.individual();
    if (!individual?.id) {
      this.toaster.error('No individual selected for document upload');
      return;
    }

    // Update upload progress to show uploading state
    this.updateUploadProgress(docType.id!, true, 0);

    // Use DocumentApiStore's upload method for better state management
    this.documentApi.upload(
      TargetEntity.INDIVIDUAL,
      individual.id,
      docType.id!,
      file,
    ).subscribe({
      next: (res) => {
        this.toaster.success(`Document "${res.fileName}" uploaded successfully`);
        this.document.set(res);
      },
      error: (err) => {
        console.error('Upload error:', err);
        this.toaster.error(`Failed to upload document: ${err.message || 'Upload failed'}`);
      },
      complete: () => {
        // Reset upload progress
        // this.updateUploadProgress(docType.id!, false, 100);
        // // Reload documents
        // this.loadIndividualDocuments(individual.id);
      },
    });

    // Subscribe to the store's state changes to track upload progress
  }
  private validateFile(file: File): boolean {
    // Check file size (max 10MB)
    const maxSize = 10 * 1024 * 1024;
    if (file.size > maxSize) {
      this.toaster.error('File size must be less than 10MB');
      return false;
    }

    // Check file type
    const allowedTypes = [
      'application/pdf',
      'image/jpeg',
      'image/jpg',
      'image/png',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    ];
    if (!allowedTypes.includes(file.type)) {
      this.toaster.error('Invalid file type. Only PDF, JPG, PNG, DOC, and DOCX files are allowed');
      return false;
    }

    return true;
  }

  private updateUploadProgress(documentTypeId: string, isUploading: boolean, progress: number): void {
    const currentProgress = this.uploadProgress();
    this.uploadProgress.set({
      ...currentProgress,
      [documentTypeId]: { isUploading, progress },
    });
  }

  // Document management methods
  getUploadedDocument(documentTypeId?: string): DocumentDTO | undefined {

    if(!documentTypeId) return undefined;

    const docs = this.uploadedDocuments() || [];
    return docs.find((doc) => doc.documentTypeId === documentTypeId);
  }

  isUploading(documentTypeId?: string): boolean {

    if(!documentTypeId) return false;

    return this.uploadProgress()[documentTypeId]?.isUploading || false;
  }

  getUploadProgress(documentTypeId?: string): number {

    if(!documentTypeId) return 0;

    return this.uploadProgress()[documentTypeId]?.progress || 0;
  }

  downloadDocument(doc: DocumentDTO): void {
    console.log(document);

    this.documentApi.downloadFile(doc.id).subscribe({
      next: (res: any) => {
        const url = window.URL.createObjectURL(res);
        const a = document.createElement('a');
        a.href = url;

        // Optional: set a meaningful filename
        a.download = `${doc.fileName}.pdf`; // or dynamically get filename from backend
        a.click();

        window.URL.revokeObjectURL(url); // clean up
      },
      error: (err: any) => {
        this.toaster.error(err.message || 'Failed to download file', 'Download Error');
      },
      complete: () => {
        // this.isDownloading.set('');
      },
    });
  }

  deleteDocument(documentTypeId?: string): void {

    if (!documentTypeId) return;

    const document = this.getUploadedDocument(documentTypeId);
    if (!document) return;

    if (confirm(`Are you sure you want to delete "${document.fileName}"?`)) {
      this.documentApi.remove(document.id).subscribe({
        next: (response) => {
          if (response.success) {
            this.loadIndividualDocuments(document.targetId!);
            this.toaster.success('Document deleted successfully');
          } else {
            this.toaster.error(`Failed to delete document: ${response.message || 'Unknown error'}`);
          }
        },
        error: (error) => {
          console.error('Delete error:', error);
          this.toaster.error(`Failed to delete document: ${error.message || 'Delete failed'}`);
        },
      });
    }
  }

  formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  private loadIndividualDocuments(individualId: string): void {
    this.documentApi.findByTarget(TargetEntity.INDIVIDUAL, individualId).subscribe({
      next: (res) => {
        this.uploadedDocuments.set(res);
      },
      error: (err) => {
        console.error('Failed to load documents:', err);
      },
    });
  }

  addKycRecord() {

    Swal.fire({
      title: 'Add KYC Record',
      text: 'Are you sure you want to add a new KYC record for this individual?',
      icon: 'question',
      showCancelButton: true,
      confirmButtonText: 'Yes, add it!',
      cancelButtonText: 'No, cancel',
    }).then((result) => {
      if (result.isConfirmed) {
        const individual: IndividualDTO = this.individual();

        let kycRecord: KycRecordDTO = new KycRecordDTO();
        kycRecord.targetId = individual?.id;
        kycRecord.target = TargetEntity.INDIVIDUAL;
        kycRecord.identityNo = individual?.identityNo || '';
        kycRecord.kycStatus = KycComplianceStatus.CURRENT;
        kycRecord.name = individual.firstName + ' ' + (individual.surname || '');

        if (individual?.id) {
          this.kycRecordApi.save(
            kycRecord
          ).subscribe({
            next: (response) => {
             this.router.navigate(['kyc'], { queryParams: { id: response.id } });
            },
            error: (error) => {
              console.error('Add KYC record error:', error);
              this.toaster.error(`Failed to add KYC record: ${error.message || 'Operation failed'}`);
            },
          });
        } else {
          this.toaster.error('No individual selected to add KYC record');
        }
      }
    });

  }

  override createNewPhoneNumbers(): PhoneNumber {
    return new PhoneNumber();
  }
}
